------------------------------------------------------------
포인터와 배열의 관계

배열의 이름은 포인터이다. 단, 그 값을 바꿀 수 없는 '상수 형태의 포인터'이며, 배열의 이름을 '포인터 상수'라 부르기도 한다.

				포인터 변수		배열의 이름
이름이 존재하는가?			존재한다.			존재한다.
무엇을 나타내거나 저장하는가?	메모리의 주소 값		메모리의 주소값
주소 값의 변경이 가능한가?		가능하다.			불가능하다.

포인터를 배열의 이름처럼 사용할 수도 있다.
배열의 이름과 포인터 변수는 변수냐 상수냐의 특성적 차이가 있을 뿐, 둘 다 포인터이기 때문에 포인터 변수로 할 수 있는 연산은 배열의 이름으로 할 수 있고,
배열의 이름으로 할 수 있는 연산은 포인터 변수로도 할 수 있다.

int arr[3] = { 15, 25, 35 };
int* ptr = &arr[0]; // int * ptr = arr; 과 동일한 문장
printf("%d %d\n", ptr[0], arr[0]);	// 15 15
printf("%d %d\n", ptr[1], arr[1]);	// 25 25
printf("%d %d\n", ptr[2], arr[2]);	// 35 35
printf("%d %d\n", *ptr, *arr);		// 15 15

------------------------------------------------------------
포인터 연산

포인터를 대상으로 하는 증가 및 감소연산을 진행할 수 있다.
printf("%p %p \n", ptr1 + 1, ptr1 + 2); 	//00000014 00000018  // 4씩증가(int)
printf("%p %p \n", ptr2 + 1, ptr2 + 2); 	//00000018 00000020  // 8씩증가(double) // 16진수라 20이 되는게 맞음
printf("%p %p \n", ptr1, ptr2); 		// 00000010 00000010
ptr1++; 					// 저장된 값을 증가시킴
ptr2++; 					// 저장된 값을 증가시킴
printf("%p %p \n", ptr1, ptr2); 		// 00000014 00000018

추가 : ptr1++는 ptr1의 값을 증가시킨 후 ptr1에 저장하지만, ptr1+1, ptr1+2의 경우는 ptr1에 저장된 값을 변경시키지는 않음

포인터의 연산특성을 이용한 배열접근
int arr[3] = { 11, 22, 33 };
int* ptr = arr;
printf("%d %d %d\n", *ptr, *(ptr + 1), *(ptr + 2)); 	// 11 22 33
printf("%d ", *ptr); ptr++; 				//11
printf("%d ", *ptr); ptr++; 				//22
printf("%d ", *ptr); ptr--; 				//33
printf("%d ", *ptr); ptr--; 				//22
printf("%d ", *ptr);					//11

중요한 결론! arr[i] == *(arr+i)
int arr[3] = { 11, 22, 33 };
int* ptr = arr;
// ptr에 저장된 값이 arr의 주소 값이기 때문에 다음 네 문장은 사실상 값은 것이며 실제로 모두 동일한 출력결과를 보인다.
printf("%d %d %d\n", *(ptr+0), *(ptr + 1), *(ptr + 2)); // *(ptr+0)는 *ptr과 같다.
printf("%d %d %d\n", ptr[0], ptr[1], ptr[2]);
printf("%d %d %d\n", *(arr + 0), *(arr + 1), *(arr + 2)); // *(arrr+0)는 *arr과 같다.
printf("%d %d %d\n", arr[0], arr[1], arr[2]);
------------------------------------------------------------
상수 형태의 문자열을 가리키는 포인터

두가지 형태의 문자열 표현
char str1[] = "My String";		// 변수 형태의 문자열
char* str2 = "Your String";		// 상수 형태의 문자열
printf("%s %s\n", str1, str2);
str2 = "Our String";		//가리키는 대상 변경
printf("%s %s\n", str1, str2);
str1[0] = 'X'; // 문자열 변경 성공
str2[0] = 'X'; // 문자열 변경 실패
printf("%s %s\n", str1, str2); 		// 위에 라인을 주석처리하지않으면 아예나오지 않음

어디서든 선언할 수 있는 상수 형태의 문자열
큰 따옴표로 묶어서 표현되는 문자열은 그 형태에 상관없이 메모리 공간에 저장된 후 그 주소값이 반환된다.
char * str = "const string"; 	// char * str = 0x1234;
printf("%s", str); 		// printf함수는 문자열을 통째로 전달받는 함수가 아닌, 문자열의 주소 값을 전달받는 함수이다.  // printf(0x1234);
------------------------------------------------------------
포인터 변수로 이뤄진 배열 : 포인터 배열

포인터 변수로 이뤄진, 그래서 주소 값의 저장이 가능한 배열을 '포인터 배열'이라고 한다.
int num1 = 10, num2 = 20, num3 = 30;
int* arr[3] = { &num1, &num2, &num3 };
printf("%d %d %d", *arr[0], *arr[1], *arr[2]);	//10 20 30

문자열을 저장하는 포인터 배열
char* strArr[3] = { "Simple", "String", "Array" };
// 큰따옴표로 묶여서 표현되는 문자열은 그 형태에 상관없이 메모리 공간에 저장된 후 그 주소 값이 반환된다.
// char* strArr[3] = {0x1004, 0x1048, 0x2012}; // 반환된 주소값은 임의로 결정하였다.
printf("%s %s %s", strArr[0], strArr[1], strArr[2]);// printf함수는 문자열을 통째로 전달받는 함수가 아닌, 문자열의 주소 값을 전달받는 함수이다.
