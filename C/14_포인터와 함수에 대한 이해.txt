------------------------------------------------------------
함수의 인자로 배열 전달하기

인자전달의 기본방식은 값의 복사이다.

배열의 함수의 인자로 전달하는 방식
void ShowArayElem(int * param, int len){...}
void ShowArayElem(int param[], int len){...}	// int param[]과 int *param은 완전히 동일한 선언이다. ("매개변수일 경우에만" int ptr[] = arr; 이런식으로는 안 됨 )

함수 내에서는 인자로 전달된 배열의 길이를 계산할 수 없음
배열의 주소 값을 인자로 전달받은 매개변수는 포인터 변수이기 때문에 이를 대상으로 sizeof 연산을 할 경우 배열의 크기가 아닌 포인터 변수의 크기가 반환된다.
이렇듯 함수 내에서는 인자로 전달된 배열의 길이를 계산할 수 없기 때문에 배열의 크기나 길이정보도 함께 인자로 전달해야 한다.
------------------------------------------------------------
Call-by-value vs Call-by-reference

함수를 호출할 때 단순히 값을 전달하는 형태의 함수호출이 call-by-value, 메모리의 접근에 사용되는 주소 값을 전달하는 형태의 함수호출을 call-by-reference라 한다.

scanf 호출 시 &연산자를 붙이는 이유
int num;
char str[30];
scanf("%d", &num);	//변수 num의 주소 값을 scanf 함수에 전달
scanf("%s", str) // scanf("%s", &str)은 잘못된 문장 구성(str 자체가 배열의 주소값을 가리킴)
------------------------------------------------------------
포인터 대상의 const 선언

// const가 맨앞에 붙을 경우 : 포인터가 가리키는 변수의 값이 고정
// const가 포인터 변수 이름 앞에 붙을 경우 : 주소 값의 변경이 불가능해짐
int num=20;
const int * ptr1 = &num;		// 포인터 변수 ptr을 이용해서 ptr이 가리키는 변수에 저장된 값을 변경하지 못함
int * const ptr2 = &num;		// 포인터 변수 ptr이 상수이며 한번 주소 값이 저장되면 그 값의 변경이 불가능해짐
const int * const ptr = &num;	// 포인터 변수 ptr의 주소값 변경이 되지 않으면 ptr이 가리키는 변수에 저장된 값도 변경하지 못함